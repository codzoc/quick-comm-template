rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null && 
             exists(/databases/$(database)/documents/admins/$(request.auth.token.email)) &&
             get(/databases/$(database)/documents/admins/$(request.auth.token.email)).data.role == 'admin';
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Helper function to validate required fields
    function hasRequiredFields(data, fields) {
      return fields.toSet().difference(data.keys().toSet()).size() == 0;
    }

    // Admins collection - read for authenticated users, write for admins only
    // Note: Storage rules can read Firestore regardless of these rules (server-side)
    match /admins/{email} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Customers collection - users can read/write own data
    match /customers/{customerId} {
      // Allow reading own customer document or admin access
      allow get: if isOwner(customerId) || isAdmin();
      
      // Allow querying customers collection for email existence checks during checkout
      // This is needed for the checkout flow to check if an email is already registered
      // Security Note: This allows public list access for email checking.
      // The client implementation limits queries to 1 document and only checks existence.
      // Consider moving email existence checks to a Cloud Function for better security
      // in production environments with high traffic.
      allow list: if true;
      
      allow create: if request.auth != null && request.auth.uid == customerId;
      allow update: if isOwner(customerId) || isAdmin();
      allow delete: if isAdmin();
    }

    // Addresses collection - users can manage own addresses
    match /addresses/{addressId} {
      allow read: if request.auth != null && 
                     (resource.data.customerId == request.auth.uid || isAdmin());
      allow create: if request.auth != null && 
                       request.resource.data.customerId == request.auth.uid;
      allow update, delete: if request.auth != null && 
                               (resource.data.customerId == request.auth.uid || isAdmin());
    }

    // Orders collection - users can read own orders, admins can manage all
    // Allow guest checkout (create without auth)
    match /orders/{orderId} {
      // Customers can read their own orders, admins can read all
      allow read: if isAdmin() || 
                     (request.auth != null && resource.data.customerId == request.auth.uid) ||
                     (resource.data.customerId == null);
      
      // Anyone can create orders (guest checkout support)
      allow create: if request.resource.data.keys().hasAll(['orderId', 'items', 'customer', 'status', 'total', 'createdAt'])
        && request.resource.data.items is list
        && request.resource.data.items.size() > 0
        && request.resource.data.customer.keys().hasAll(['name', 'phone', 'address', 'pin'])
        && request.resource.data.customer.name is string
        && request.resource.data.customer.phone is string
        && request.resource.data.total is number
        && request.resource.data.total >= 0
        && request.resource.data.status == 'pending'
        // Allow optional customerId, subtotal, tax, and shipping fields
        && (!request.resource.data.keys().hasAny(['subtotal', 'tax', 'shipping']) ||
            (request.resource.data.get('subtotal', 0) is number &&
             request.resource.data.get('tax', 0) is number &&
             request.resource.data.get('shipping', 0) is number));
      
      // Only admins can update/delete orders
      allow update, delete: if isAdmin();
    }

    // Products collection
    // Public: read (view products)
    // Admin: full access (CRUD)
    // Public: update stock (for order transactions)
    match /products/{productId} {
      allow read: if true;

      allow create: if isAdmin()
        && hasRequiredFields(request.resource.data, ['title', 'description', 'price', 'stock'])
        && request.resource.data.title is string
        && request.resource.data.description is string
        && request.resource.data.price is number
        && request.resource.data.price >= 0
        && request.resource.data.stock is number
        && request.resource.data.stock >= 0
        // Must have either imagePath or images array
        && (request.resource.data.keys().hasAny(['imagePath']) || 
            (request.resource.data.keys().hasAny(['images']) && request.resource.data.images is list));

      allow update: if isAdmin()
        && request.resource.data.keys().hasAny(['title', 'description', 'price', 'discountedPrice', 'imagePath', 'images', 'stock', 'tags', 'updatedAt']);

      // Allow public to update stock during order transactions (stock decrease only)
      allow update: if request.resource.data.stock is number
        && request.resource.data.stock >= 0
        && request.resource.data.stock <= resource.data.stock;

      allow delete: if isAdmin();
    }

    // Settings collection (about, terms, privacy static pages, theme)
    // Public: read
    // Admin: read, write
    match /settings/{settingId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Store settings collection (payment settings, etc)
    match /store_settings/{settingId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // Store info collection (contact details, social media, SEO, pricing, logo)
    // Public: read
    // Admin: read, write
    match /storeInfo/{infoId} {
      allow read: if true;
      allow write: if isAdmin();
    }
  }
}
