name: Deploy

on:
  # Manual trigger from Actions tab - click "Run workflow"
  workflow_dispatch:
    inputs:
      skip_template_update:
        description: 'Skip template update'
        required: false
        default: 'false'
        type: boolean
  
  # Automatic weekly template updates every Monday at 9 AM UTC
  schedule:
    - cron: '0 9 * * 1'
  
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

# Permissions for the workflow
permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write

jobs:
  # Template update job (always runs for build dependency, but steps are conditional)
  update-from-template:
    runs-on: ubuntu-latest
    outputs:
      updated: ${{ steps.check-updates.outputs.has_updates || 'false' }}
      merge_success: ${{ steps.auto-merge.outputs.merge_success || 'false' }}
      should_run: ${{ steps.should-update.outputs.should_run || 'false' }}
    
    steps:
      - name: Check if template update should run
        id: should-update
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]] || \
             ([[ "${{ github.event_name }}" == "workflow_dispatch" ]] && \
              [[ "${{ github.event.inputs.skip_template_update }}" != "true" ]] && \
              [[ "${{ github.ref }}" == "refs/heads/main" ]]); then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Template update will run"
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Template update skipped (only runs on schedule or manual trigger on main branch)"
          fi

      - name: Checkout repository
        if: steps.should-update.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        if: steps.should-update.outputs.should_run == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote and fetch updates
        if: steps.should-update.outputs.should_run == 'true'
        run: |
          git remote add upstream https://github.com/codzoc/quick-comm-template.git || true
          git fetch upstream main
          echo "‚úÖ Fetched latest updates from template repository"

      - name: Check for updates
        if: steps.should-update.outputs.should_run == 'true'
        id: check-updates
        run: |
          if git diff --quiet main upstream/main; then
            echo "has_updates=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No updates available - your repo is already up to date!"
          else
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Updates available from template"
          fi

      - name: Attempt automatic merge
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true'
        id: auto-merge
        continue-on-error: true
        run: |
          # Merge upstream changes (workflow files will be merged but excluded from commit)
          # Use --no-commit to stage changes first, then exclude workflow files before committing
          if git merge --no-commit --no-ff upstream/main --allow-unrelated-histories; then
            echo "‚úÖ Merge completed successfully"
          else
            # Merge has conflicts - resolve workflow file conflicts by keeping our version
            if git rev-parse --verify MERGE_HEAD >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Merge has conflicts"
              # Resolve workflow file conflicts by keeping our version (HEAD)
              git checkout --ours .github/workflows/ 2>/dev/null || true
              git add .github/workflows/ 2>/dev/null || true
              echo "‚úÖ Resolved workflow file conflicts (keeping current version)"
              
              # Check if there are other conflicts (non-workflow files)
              CONFLICTED_FILES=$(git diff --name-only --diff-filter=U 2>/dev/null | grep -v "^.github/workflows/" || true)
              if [ -n "$CONFLICTED_FILES" ]; then
                echo "merge_success=false" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è Automatic merge failed due to conflicts in non-workflow files"
                exit 1
              fi
            else
              # Merge completely failed
              git merge --abort 2>/dev/null || true
              echo "merge_success=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Automatic merge failed"
              exit 1
            fi
          fi
          
          # Exclude workflow files from commit (GitHub Actions cannot modify workflow files)
          # First, save the current state of workflow files
          git checkout HEAD -- .github/workflows/ 2>/dev/null || true
          
          # Stage all changes (including merged workflow files temporarily)
          git add -A
          
          # Remove workflow files from staging
          git reset HEAD .github/workflows/ 2>/dev/null || true
          
          # Restore workflow files to HEAD version (current repo's version)
          git checkout HEAD -- .github/workflows/ 2>/dev/null || true
          
          echo "‚úÖ Excluded workflow files from commit (keeping current version)"
          
          # Commit all changes except workflow files
          if git commit -m "chore: update from template repository

          Updates from codzoc/quick-comm-template

          This automated update brings the latest improvements, bug fixes, and features from the original template.
          
          Note: .github/workflows/ files are excluded from automatic updates.
          Please manually update workflow files if needed.

          ü§ñ Generated by Deploy workflow"; then
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Successfully merged and committed upstream changes (excluding workflow files)"
          else
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Commit failed"
            exit 1
          fi


      - name: Push updates to main
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'true'
        run: |
          git push origin main
          echo "‚úÖ Successfully pushed updates to main branch"

      - name: Create conflict resolution branch
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        id: conflict-branch
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH_NAME="update-from-template-${TIMESTAMP}"
          git checkout -b "${BRANCH_NAME}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "üìù Created conflict resolution branch: ${BRANCH_NAME}"

      - name: Merge with conflict markers (for PR)
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        run: |
          git merge upstream/main --allow-unrelated-histories --no-edit -m "chore: update from template repository

          Updates from codzoc/quick-comm-template

          ü§ñ Generated by Deploy workflow
          ‚ö†Ô∏è This merge has conflicts that need manual resolution" || true
          
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U || echo "Unable to determine conflicted files")
          echo "conflicted_files<<EOF" >> $GITHUB_ENV
          echo "$CONFLICTED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "‚ö†Ô∏è Files with conflicts:"
          echo "$CONFLICTED_FILES"

      - name: Exclude workflow files from conflict commit (workflows cannot be updated by actions)
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        run: |
          # Remove workflow files from any staged changes
          # GitHub Actions cannot modify workflow files, so these must be updated manually
          git reset HEAD .github/workflows/ 2>/dev/null || true
          git checkout HEAD -- .github/workflows/ 2>/dev/null || true
          # Also resolve any workflow file conflicts by keeping HEAD version
          git checkout --ours .github/workflows/ 2>/dev/null || true
          # Stage the resolved workflow files (keeping current version)
          git add .github/workflows/ 2>/dev/null || true
          echo "‚úÖ Workflow files excluded from conflict commit (keeping current version)"
          echo "‚ÑπÔ∏è Please review and manually update workflow files if needed"

      - name: Commit conflict markers
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        run: |
          # Stage all changes except workflow files (workflow files already staged with HEAD version)
          git add -A
          # Unstage workflow files to ensure they're not included in the commit
          git reset HEAD .github/workflows/ 2>/dev/null || true
          # Restore workflow files to HEAD version (already done above, but ensure it's done)
          git checkout HEAD -- .github/workflows/ 2>/dev/null || true
          # Commit without workflow files
          git commit -m "chore: update from template repository (conflicts to resolve)

          Updates from codzoc/quick-comm-template

          ‚ö†Ô∏è This merge has conflicts that need manual resolution.
          Please review the files marked with conflicts and resolve them.

          ü§ñ Generated by Deploy workflow" || echo "No changes to commit"

      - name: Push conflict resolution branch
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        run: |
          git push origin ${{ steps.conflict-branch.outputs.branch_name }}
          echo "‚úÖ Pushed conflict resolution branch"

      - name: Create Pull Request for conflict resolution
        if: steps.should-update.outputs.should_run == 'true' && steps.check-updates.outputs.has_updates == 'true' && steps.auto-merge.outputs.merge_success == 'false'
        id: create-pr
        run: |
          CONFLICTED_FILES_ESCAPED=$(echo "${{ env.conflicted_files }}" | jq -Rs .)

          PR_BODY="## ‚ö†Ô∏è Template Update - Conflicts Need Resolution

          This PR contains updates from the [quick-comm-template](https://github.com/codzoc/quick-comm-template) repository, but **automatic merge failed due to conflicts**.

          ### üîç What Happened

          The workflow tried to automatically merge the latest template changes into your \`main\` branch, but some files have conflicts that need your attention.

          ### üìã Files with Conflicts

          The following files have merge conflicts:

          \`\`\`
          ${{ env.conflicted_files }}
          \`\`\`

          ### ‚úÖ How to Resolve Conflicts

          **Option 1: Resolve in GitHub (Easiest)**

          1. Click the **\"Resolve conflicts\"** button above
          2. GitHub will show you each conflicting file
          3. Edit the files to keep the changes you want
          4. Remove the conflict markers (\`<<<<<<<\`, \`=======\`, \`>>>>>>>\`)
          5. Click **\"Mark as resolved\"** for each file
          6. Click **\"Commit merge\"**
          7. Merge this PR

          **Option 2: Resolve Locally**

          1. Clone your repository: \`git clone <your-repo-url>\`
          2. Checkout this branch: \`git checkout ${{ steps.conflict-branch.outputs.branch_name }}\`
          3. Resolve conflicts in your editor
          4. Stage changes: \`git add .\`
          5. Commit: \`git commit -m \"Resolve merge conflicts\"\`
          6. Push: \`git push origin ${{ steps.conflict-branch.outputs.branch_name }}\`
          7. Merge this PR

          ### üéØ What's Being Updated

          This update brings you:
          - ‚ú® New features and improvements
          - üêõ Bug fixes
          - üìö Documentation updates
          - üîß Configuration enhancements

          ### üí° Understanding Conflict Markers

          In conflicted files, you'll see markers like this:

          \`\`\`
          <<<<<<< HEAD
          Your current code
          =======
          Template's new code
          >>>>>>> upstream/main
          \`\`\`

          - Keep the code you want (yours, template's, or a combination)
          - Delete the conflict markers
          - Save the file

          ### üõ°Ô∏è Safety Notes

          - You can always close this PR if you don't want the updates
          - Your customizations in \`src/config/business.js\`, \`src/config/theme.js\`, etc. should be kept

          ---

          ü§ñ This PR was automatically created by the **Deploy** workflow."

          PR_BODY_JSON=$(echo "$PR_BODY" | jq -Rs .)

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/pulls \
            -d "{\"title\":\"‚ö†Ô∏è Update from template (conflicts need resolution)\",\"head\":\"${{ steps.conflict-branch.outputs.branch_name }}\",\"base\":\"main\",\"body\":$PR_BODY_JSON}")

          PR_URL=$(echo "$RESPONSE" | jq -r .html_url)
          PR_NUMBER=$(echo "$RESPONSE" | jq -r .number)

          if [ "$PR_URL" != "null" ] && [ "$PR_URL" != "" ]; then
            echo "pull-request-url=$PR_URL" >> $GITHUB_OUTPUT
            echo "pull-request-number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "‚úÖ Pull Request created: $PR_URL"
          else
            echo "‚ùå Failed to create PR"
            echo "$RESPONSE" | jq .
            exit 1
          fi

  # Build job - runs for PRs and pushes (always after template update)
  build:
    runs-on: ubuntu-latest
    needs: update-from-template
    if: |
      github.event_name == 'pull_request' || 
      github.event_name == 'push' || 
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci
        env:
          CI: true

      - name: Create .env and .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq -r '"VITE_FIREBASE_API_KEY=" + .apiKey' > .env
          cat config.json | jq -r '"VITE_FIREBASE_AUTH_DOMAIN=" + .authDomain' >> .env
          cat config.json | jq -r '"VITE_FIREBASE_PROJECT_ID=" + .projectId' >> .env
          cat config.json | jq -r '"VITE_FIREBASE_STORAGE_BUCKET=" + .storageBucket' >> .env
          cat config.json | jq -r '"VITE_FIREBASE_MESSAGING_SENDER_ID=" + .messagingSenderId' >> .env
          cat config.json | jq -r '"VITE_FIREBASE_APP_ID=" + .appId' >> .env
          cat config.json | jq -r '"VITE_FIREBASE_MEASUREMENT_ID=" + .measurementId' >> .env
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Build project
        run: npm run build

      - name: Copy .firebaserc to dist
        run: cp .firebaserc dist/.firebaserc

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: dist/
          include-hidden-files: true
          retention-days: 1

  # Setup Firebase permissions and authentication (runs once for all deployment jobs)
  setup-firebase:
    runs-on: ubuntu-latest
    needs: build
    if: always() && needs.build.result == 'success'
    
    outputs:
      project_id: ${{ steps.firebase-config.outputs.project_id }}
    
    steps:
      - name: Create .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Grant Storage Service Account IAM Role for Firestore Access
        continue-on-error: true
        run: |
          PROJECT_ID="${{ steps.firebase-config.outputs.project_id }}"
          STORAGE_SA="service-$(gcloud projects describe $PROJECT_ID --format='value(projectNumber)')@gs-project-accounts.iam.gserviceaccount.com"
          echo "Granting Datastore User role to Storage service account: $STORAGE_SA"
          gcloud projects add-iam-policy-binding $PROJECT_ID \
            --member="serviceAccount:$STORAGE_SA" \
            --role="roles/datastore.user" \
            --condition=None
          echo "‚úÖ Storage service account permission granted (or already exists)"

      - name: Grant necessary Firebase permissions to service account
        continue-on-error: true
        run: |
          PROJECT_ID="${{ steps.firebase-config.outputs.project_id }}"
          
          # Get the service account email from the credentials
          SERVICE_ACCOUNT_EMAIL=$(echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' | jq -r '.client_email')
          
          echo "Granting necessary permissions to service account: $SERVICE_ACCOUNT_EMAIL"
          echo "Note: If this fails, ensure the service account has Project IAM Admin role to grant these permissions."
          echo "Alternatively, grant these roles manually in Google Cloud Console IAM."
          
          # Grant Firebase Admin role
          gcloud projects add-iam-policy-binding $PROJECT_ID \
            --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
            --role="roles/firebase.admin" \
            --condition=None || echo "Firebase Admin role already granted or insufficient permissions to grant"
          
          # Grant Cloud Functions Admin role (for functions deployment)
          gcloud projects add-iam-policy-binding $PROJECT_ID \
            --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
            --role="roles/cloudfunctions.admin" \
            --condition=None || echo "Cloud Functions Admin role already granted or insufficient permissions to grant"
          
          # Grant Storage Admin role (for storage rules deployment)
          gcloud projects add-iam-policy-binding $PROJECT_ID \
            --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
            --role="roles/storage.admin" \
            --condition=None || echo "Storage Admin role already granted or insufficient permissions to grant"
          
          # Grant Service Account User role (for functions to use other service accounts)
          gcloud projects add-iam-policy-binding $PROJECT_ID \
            --member="serviceAccount:$SERVICE_ACCOUNT_EMAIL" \
            --role="roles/iam.serviceAccountUser" \
            --condition=None || echo "Service Account User role already granted or insufficient permissions to grant"
          
          echo "‚úÖ Firebase permissions check complete (roles may already be granted)"


  # Deploy Firestore (rules and indexes) - runs in parallel with other deployments
  deploy-firestore:
    runs-on: ubuntu-latest
    needs: setup-firebase
    if: always() && needs.setup-firebase.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy Firestore Rules and Indexes
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only firestore --project ${{ steps.firebase-config.outputs.project_id }}
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Deploy Firestore Rules and Indexes (Preview)
        if: github.event_name == 'pull_request'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only firestore --project ${{ steps.firebase-config.outputs.project_id }}
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

  # Deploy Storage Rules - runs in parallel with other deployments
  deploy-storage:
    runs-on: ubuntu-latest
    needs: setup-firebase
    if: always() && needs.setup-firebase.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy Storage Rules
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only storage --project ${{ steps.firebase-config.outputs.project_id }} --non-interactive
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Deploy Storage Rules (Preview)
        if: github.event_name == 'pull_request'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only storage --project ${{ steps.firebase-config.outputs.project_id }} --non-interactive
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

  # Deploy Functions - runs in parallel with other deployments
  deploy-functions:
    runs-on: ubuntu-latest
    needs: setup-firebase
    if: always() && needs.setup-firebase.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: functions/package-lock.json

      - name: Install Functions Dependencies
        working-directory: functions
        run: npm ci

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy Functions
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only functions --force --project ${{ steps.firebase-config.outputs.project_id }}
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

      - name: Deploy Functions (Preview)
        if: github.event_name == 'pull_request'
        uses: w9jds/firebase-action@master
        with:
          args: deploy --only functions --force --project ${{ steps.firebase-config.outputs.project_id }}
        env:
          GCP_SA_KEY: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

  # Deploy Hosting - runs in parallel with other deployments
  deploy-hosting:
    runs-on: ubuntu-latest
    needs: [build, setup-firebase]
    if: always() && needs.build.result == 'success' && needs.setup-firebase.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: dist/

      - name: Create .firebaserc from config
        run: |
          echo '${{ secrets.VITE_FIREBASE_CONFIG }}' > config.json
          cat config.json | jq '{projects: {default: .projectId}}' > .firebaserc
          rm config.json

      - name: Extract project ID
        id: firebase-config
        run: |
          PROJECT_ID=$(cat .firebaserc | jq -r '.projects.default')
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Deploy to Firebase Preview Channel
        if: github.event_name == 'pull_request'
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          projectId: '${{ steps.firebase-config.outputs.project_id }}'
          expires: 7d
        env:
          FIREBASE_CLI_PREVIEWS: hostingchannels

      - name: Deploy to Firebase Hosting (Production)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          projectId: '${{ steps.firebase-config.outputs.project_id }}'
          channelId: live

